import path from 'path';
import Koa from 'koa';
import Router from 'koa-router';
import proxy from 'koa-proxy';
import staticMiddleware from 'koa-static';
import pkgup from 'pkg-up';
import { merge, get, has } from 'lodash';
import loadView from '@bmo/loadView';
import es6Require from '@bmo/es6Require';
import loadDependencies from '@bmo/loadDependencies';
import loadMiddleware from './loadMiddleware';
import swagger from './swagger';
import requestValidator from './requestValidator';

const REQUEST_BODY_SCHEMA = 'schema.requestBody';

const paths = (dir) => ({
	dependencies: path.resolve(dir, './dependencies'),
	routes: path.resolve(dir, './routes'),
	middleware: path.resolve(dir, './middleware'),
	views: path.resolve(dir, './views')
});

export default class HttpServer {
	constructor (config) {
		this._app = new Koa();
		this.config = config;
		console.log(this.config);
	}

	get appName () {
		return this.pkg.name;
	}

	get appVersion () {
		return this.pkg.version;
	}

	get appDescription () {
		return this.pkg.decription;
	}

	get appLicense () {
		return this.pkg.license;
	}

	get app () {
		return this._app;
	}

	get baseDir () {
		return this.config.baseDir || process.cwd();
	}

	get paths () {
		if (!this._paths) {
			this._paths = paths(this.baseDir);
		}
		return this._paths;
	}

	get port () {
		return this.config.server.port;
	}

	async start () {
		if (this._started) {
			throw new Error(`Cannot start same server twice.`);
		}
		this._started = true;
		this._pkg = await pkgup();
		await this._loadDependencies();
		await this._loadMiddleware();
		await this._loadRoutes();
		// await this._loadViews();
		await this.app.listen(this.port);
	}

	async _loadDependencies () {
		const dependencies = es6Require(this.paths.dependencies);
		const routes = es6Require(this.paths.routes);
		// const middleware = es6Require(this.middlewarePath);

		this.manifest = await loadDependencies(this.config, {
			...dependencies,
			routes
		//	middleware
		});
		console.log('Loaded manifest');
		console.log(this.manifest);
	}

	// TODO Clean up and DI routes
	async _loadRoutes () {
		const { routes } = this.manifest.services;
		swagger({ manifest: this.manifest, app: this.app, routes, Router });
		routes.forEach((route) => this._loadRoute(route));
	}

	_loadRoute (route) {
		const apiRouter = new Router();
		if (has(route, REQUEST_BODY_SCHEMA)) {
			const schema = get(route, REQUEST_BODY_SCHEMA);
			apiRouter.use(requestValidator(schema));
		}
		if (Array.isArray(route.handler)) {
			const handler = route.handler.slice(-1)[0];
			const middleware = route.handler.slice(0, route.handler.length - 1);
			middleware.forEach((mw) => {
				apiRouter.use(route.path, mw);
			});
			apiRouter[route.method.toLowerCase()](route.path, handler);
		} else {
			apiRouter[route.method.toLowerCase()](route.path, route.handler);
		}
		this.app.use(apiRouter.routes(), apiRouter.allowedMethods());
	}

	async _loadMiddleware () {
		// await _loadCustomMiddleware(this.manifest);
		await loadMiddleware(this.manifest, this.app);
	}

	async _loadCustomMiddleware () {

	}
}
