import { parse as parseAst } from 'esprima';
import { parse as parseQuery, match } from 'esquery';
import { get, set, each, isFunction, isObject } from 'lodash';

const DEPENDENCY_PROPERTY = 'services';

export default async (config, dependencies) => {
	const services = {};
	const manifest = {
		config,
		[DEPENDENCY_PROPERTY]: services
	};
	Object.keys(dependencies).forEach(key => {
		loadDependency(manifest, key, dependencies[key], dependencies, {});
	});
	return manifest;
};

const loadDependency = (manifest, name, dependency, dependencies, depChain, path = []) => {
	if (isFunction(dependency)) {
		const deps = extractDependencies(dependency.toString());
		console.log(deps);
		deps.forEach((dep) => {
			if (!manifest[DEPENDENCY_PROPERTY][dep] && dep !== name) {
				if (depChain[dep]) {
					throw new Error(`circular dependency detected. ${dep} is already in ${name}'s dependency chain.`);
				}
				if (!dependencies[dep]) {
					throw new Error(`Unknown dependency ${dep} in module: ${name}`);
				}
				depChain[dep] = true;
				manifest[DEPENDENCY_PROPERTY][dep] = loadDependency(manifest, dep, dependencies[dep], dependencies, depChain);
			}
		});
		const fullPath = path.length > 0 ? `${path.join('.')}.${name}` : name;
		set(manifest, `${DEPENDENCY_PROPERTY}.${fullPath}`, dependency(manifest));
	} else if (isObject(dependency)) {
		path.push(name);
		each(dependency, (dep, subName) =>
			loadDependency(manifest, subName, dep, dependencies, depChain, path));
	} else {
		throw new Error(`Dependency ${path.join('.')}.${name} must be either a function or object type ${typeof dependency} not injectable`);
	}

	return manifest;
};

const extractDependencies = (fnString) => {
	const ast = parseAst(fnString);
	// console.log(JSON.stringify(ast, 0, 2));
	const root = ast.body[0];
	if (paramParsers[root.type]) {
		const params = paramParsers[root.type](root);
		return params;
	} else {
		console.log(`NO PARSER FOR: ${root.type}`);
	}

	return [];
};

const paramParsers = {
	ExpressionStatement: (root) => {
		const configParam = root.expression.params[0];
		if (configParam && configParsers[configParam.type]) {
			return configParsers[configParam.type](root, configParam);
		}
		return [];
	},
	FunctionDeclaration: (root) => {
		const configParam = root.params[0];
		if (configParam && configParsers[configParam.type]) {
			return configParsers[configParam.type](root, configParam);
		}
		return [];
	}
};

const configParsers = {
	Identifier: (root, configNode) => {
		// find any references to config.dependencies.thing
		// from the root down
		const query = parseQuery('[type="MemberExpression"]');
		const expressions = match(root, query);
		console.log(JSON.stringify(expressions, 0, 2));
		return expressions
			.filter((n) => get(n, 'object.object.name') === configNode.name && get(n, 'object.property.name') === DEPENDENCY_PROPERTY)
			.map((n) => get(n, 'property.name'));
	},
	ObjectPattern: (root, configNode) => {
		// find
		let deps = [];
		const dependencyNode = configNode.properties.filter(n => n.key.name === DEPENDENCY_PROPERTY)[0];
		if (dependencyNode) {
			deps = get(dependencyNode, 'value.properties', []).map((n) => n.key.name);
		}
		return deps;
	}
};
