import { parse as parseAst } from 'esprima';
import { parse as parseQuery, match } from 'esquery';
import { map, get, set, each, isFunction, isObject } from 'lodash';

const DEPENDENCY_PROPERTY = 'services';

// TODO make 'services configurable'
export default async (config, dependencies) => {
	console.log(dependencies);
	const services = {};
	const manifest = {
		config,
		[DEPENDENCY_PROPERTY]: services
	};
	const formedManifest = await Promise.all(
		Object.keys(dependencies).map(async (key) => await loadDependency(manifest, key, dependencies[key], dependencies, {}))
	);
	return formedManifest[0];
};

const loadDependency = async (manifest, name, dependency, dependencies, depChain, path = []) => {
	if (isFunction(dependency)) {
		const deps = extractDependencies(dependency.toString());
		await Promise.all(deps.map(async (dep) => {
			if (!manifest[DEPENDENCY_PROPERTY][dep] && dep !== name) {
				// if (depChain[dep]) {
				// 	throw new Error(`circular dependency detected. ${dep} is already in ${name}'s dependency chain. ${JSON.stringify(depChain, 0, 2)}`);
				// }
				if (!dependencies[dep]) {
					throw new Error(`Unknown dependency ${dep} in module: ${fullPath.join('.')}${name}`);
				}
				console.log(`Loading dependency ${dep} for ${name}`);
				depChain[dep] = true;
				// manifest[DEPENDENCY_PROPERTY][dep] = loadDependency(manifest, dep, dependencies[dep], dependencies, depChain);
				manifest = await loadDependency(manifest, dep, dependencies[dep], dependencies, depChain);
			}
		}));
		const fullPath = path.length > 0 ? `${path.join('.')}.${name}` : name;
		const value = await dependency(manifest);
		set(manifest, `${DEPENDENCY_PROPERTY}.${fullPath}`, value);
	} else if (isObject(dependency)) {
		path.push(name);
		await Promise.all(map(dependency, async (dep, subName) => await loadDependency(manifest, subName, dep, dependencies, depChain, path)));
	} else if (isArray(dependency)) {
		await Promise.all(map(dependency, async (dep, index) => await loadDependency(manifest, `[${index}]`, dep, dependencies, depChain, path)));
	} else {
		throw new Error(`Dependency ${path.join('.')}.${name} must be either a function or object type ${typeof dependency} not injectable`);
	}
	return manifest;
};

// TODO cleanup and move to external file
const extractDependencies = (fnString) => {
	const ast = parseAst(fnString);
	// console.log(JSON.stringify(ast, 0, 2));
	const root = ast.body[0];
	if (paramParsers[root.type]) {
		const params = paramParsers[root.type](root);
		return params;
	} else {
		console.log(`NO PARSER FOR: ${root.type}`);
	}

	return [];
};

const paramParsers = {
	ExpressionStatement: (root) => {
		const configParam = root.expression.params[0];
		if (configParam && configParsers[configParam.type]) {
			return configParsers[configParam.type](root, configParam);
		}
		return [];
	},
	FunctionDeclaration: (root) => {
		const configParam = root.params[0];
		if (configParam && configParsers[configParam.type]) {
			return configParsers[configParam.type](root, configParam);
		}
		return [];
	}
};

const configParsers = {
	Identifier: (root, configNode) => {
		// find any references to config.dependencies.thing
		// from the root down
		const query = parseQuery('[type="MemberExpression"]');
		const expressions = match(root, query);
		console.log(JSON.stringify(expressions, 0, 2));
		return expressions
			.filter((n) => get(n, 'object.object.name') === configNode.name && get(n, 'object.property.name') === DEPENDENCY_PROPERTY)
			.map((n) => get(n, 'property.name'));
	},
	ObjectPattern: (root, configNode) => {
		// find
		let deps = [];
		const dependencyNode = configNode.properties.filter(n => n.key.name === DEPENDENCY_PROPERTY)[0];
		if (dependencyNode) {
			deps = get(dependencyNode, 'value.properties', []).map((n) => n.key.name);
		}
		return deps;
	}
};
