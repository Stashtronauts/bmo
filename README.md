# BMO

BMO is a server side framework, focused at enabling developers to quickly implement high quality Restful services,
but it can be used to implement any kind of http server.
Aims to reduce boiler plate code by having an opinionated project structure, and provide
flexibility in code by providing robust unobtrusive dependency injection.

## Project structure
BMO expects your project to be structured with some folder.
In the 'baseDirectory' BMO expects there to be several folders
```
|-\
|--config
|--dependencies
|--routes
```
BMO expects the top level modules to export certain things.

### Config
The config directory is expected to export an async function that takes in an object parsed from the command line.

```
export default async cliParams =>({
  // my configuration object
  })
```
### Dependencies
The dependencies directory should export an object. each key on the object should be either: another object, an array, or a function (async or sync).
Each leaf function will be invoked with the manifest generated by running it through BMO's DI framework
each return value will be available in the dependencies portion of the manifest. see [DI](#DI) for more information on how dependency injection is done.

```
export default async ({ config, dependencies :{ myDependency } }) => ({
    // my module object
  })
```

### Routes
The routes folder is where you declare your routes.
It should export an array of functions that when invoked returns a route object

```
export default async ({config, dependencies}) => ({
  path:'api/things/v1/',
  method:'post',
  schema:{
    requestBody,
    responseBody
  },
  handler:async(ctx,next)=>{}
})
```
- `path` - indicates what the path to the handers should be.
- `method` - is the http method that the handler is for.
- `schema`- schema takes in two sub objects, these objects should be joi schemas that are then used to
generate OpenAPI documentation for the resources. These are optional and will be ignored if not supplied.
- `handler`- Is an async function that is invoked when a request is received with the given path and method.


#CLI

BMO comes with an easy to use command line interface. It takes care of starting up and running your application
It even comes with a dev mode that will watch your files and restart during development

install the bmo cli with your package manager of choice:

`npm install @lmig/bmo-cli`
If you want BMO can be installed at the global level,
 but it is recommended to be added on a per-project level.

once installed in your base directory you can change your start commands to be:

`bmo start`
 or
`bmo start -d`

If run in a folder structure as outlined above an http server with all the routes mounted
will be started, and available.


## DI

The DI or dependency injection that BMO supplies is meant to be totally unobtrusive.
Simply attach your constructor to the root dependencies export, and deconstruct your modules dependencies
off of the manifest passed to each constructor.

Database module Example

```
export default async ({ config, dependencies :{ connectionPool } }) => ({
    query:async (query) => {
      const connection = await connectionPool.getConnection();
      const result = await connection.execute(query)
      return result;
    }
  })
```
